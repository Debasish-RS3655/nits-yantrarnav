<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>3D Position & Target Tracker</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }

      canvas {
        display: block;
      }

      #info {
        position: absolute;
        top: 10px;
        left: 10px;
        background: rgba(0, 0, 0, 0.7);
        color: #fff;
        padding: 10px;
        font-family: monospace;
        border-radius: 5px;
      }

      #controls {
        position: absolute;
        bottom: 20px;
        left: 20px;
        display: flex;
        gap: 10px;
      }

      button {
        background: rgba(0, 0, 0, 0.7);
        color: #fff;
        border: 1px solid #666;
        padding: 10px 15px;
        border-radius: 5px;
        font-family: monospace;
        cursor: pointer;
        transition: background 0.3s;
      }

      button:hover {
        background: rgba(30, 30, 80, 0.8);
      }

      button.active {
        background: rgba(50, 100, 170, 0.8);
        border-color: #99f;
      }
    </style>
  </head>

  <body>
    <div id="info">
      <h3>Position & Target Tracker</h3>
      <p>Current Position: <span id="position">x=0 y=0 z=0</span></p>
      <p>Target Position: <span id="target">x=0 y=0 z=0</span></p>
      <p>Connection Status: <span id="status">Connecting...</span></p>
      <p>Current Axes: <span id="axes-info">Z-Up, X-Left</span></p>
      <p>Mode: <span id="mode-display">automatic</span></p>
    </div>
    <div id="controls">
      <button id="rotate-axes">Rotate Axes</button
      ><button id="reset-orientation">Reset Orientation</button
      ><button id="toggle-mode">Mode: Automatic</button>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(18483);
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1e3
      );
      camera.position.x = -100;
      camera.position.y = 100;
      camera.position.z = 100;
      camera.lookAt(0, 0, 0);
      const renderer = new THREE.WebGLRenderer({ antialias: !0 });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);
      let gridHelper = new THREE.GridHelper(100, 10, 6710886, 4473924);
      gridHelper.rotation.x = Math.PI / 2;
      scene.add(gridHelper);
      let axesHelper = new THREE.AxesHelper(60);
      axesHelper.scale.x = -1;
      scene.add(axesHelper);
      const dotGeometry = new THREE.SphereGeometry(2, 32, 32),
        dotMaterial = new THREE.MeshBasicMaterial({ color: 16711680 }),
        dot = new THREE.Mesh(dotGeometry, dotMaterial);
      scene.add(dot);
      const targetGeometry = new THREE.SphereGeometry(2, 32, 32),
        targetMaterial = new THREE.MeshBasicMaterial({ color: 65280 }),
        targetDot = new THREE.Mesh(targetGeometry, targetMaterial);
      scene.add(targetDot);
      const lineGeometry = new THREE.BufferGeometry(),
        lineMaterial = new THREE.LineBasicMaterial({ color: 16776960 }),
        targetLine = new THREE.Line(lineGeometry, lineMaterial);
      scene.add(targetLine);
      const trailPoints = [],
        trailGeometry = new THREE.BufferGeometry(),
        trailMaterial = new THREE.LineBasicMaterial({
          color: 16744704,
          opacity: 0.7,
          transparent: !0,
        }),
        trail = new THREE.Line(trailGeometry, trailMaterial);
      scene.add(trail);
      const position = { x: 0, y: 0, z: 0 },
        target = { x: 50, y: 50, z: 50 };
      let currentAxisConfig = 0;
      const axisConfigs = [
        {
          name: "Z-Up, X-Left",
          transform: (e, t, n) => ({ x: -e, y: t, z: n }),
        },
        {
          name: "Z-Up, X-Right",
          transform: (e, t, n) => ({ x: e, y: t, z: n }),
        },
        {
          name: "Y-Up, X-Left",
          transform: (e, t, n) => ({ x: -e, y: n, z: t }),
        },
        {
          name: "Y-Up, X-Right",
          transform: (e, t, n) => ({ x: e, y: n, z: t }),
        },
        {
          name: "X-Up, Z-Left",
          transform: (e, t, n) => ({ x: -n, y: t, z: e }),
        },
        {
          name: "X-Up, Z-Right",
          transform: (e, t, n) => ({ x: n, y: t, z: e }),
        },
      ];
      let currentMode = "automatic";
      const axesInfoElement = document.getElementById("axes-info"),
        rotateAxesButton = document.getElementById("rotate-axes"),
        resetOrientationButton = document.getElementById("reset-orientation"),
        toggleModeButton = document.getElementById("toggle-mode"),
        modeDisplayElement = document.getElementById("mode-display");
      function rotateAxes() {
        (currentAxisConfig = (currentAxisConfig + 1) % axisConfigs.length),
          updateOrientation();
      }
      function resetOrientation() {
        (currentAxisConfig = 0), updateOrientation();
      }
      function updateOrientation() {
        const e = axisConfigs[currentAxisConfig];
        (axesInfoElement.textContent = e.name),
          (trailPoints.length = 0),
          trailGeometry.setFromPoints([]),
          scene.remove(gridHelper),
          scene.remove(axesHelper),
          (gridHelper = new THREE.GridHelper(100, 10, 6710886, 4473924)),
          (axesHelper = new THREE.AxesHelper(60)),
          0 === currentAxisConfig
            ? ((gridHelper.rotation.x = Math.PI / 2), (axesHelper.scale.x = -1))
            : 1 === currentAxisConfig
            ? (gridHelper.rotation.x = Math.PI / 2)
            : 2 === currentAxisConfig
            ? (axesHelper.scale.x = -1)
            : 4 === currentAxisConfig
            ? ((gridHelper.rotation.z = Math.PI / 2),
              (axesHelper.rotation.z = Math.PI / 2),
              (axesHelper.scale.x = -1))
            : 5 === currentAxisConfig &&
              ((gridHelper.rotation.z = Math.PI / 2),
              (axesHelper.rotation.z = Math.PI / 2)),
          scene.add(gridHelper),
          scene.add(axesHelper),
          0 === currentAxisConfig || 1 === currentAxisConfig
            ? camera.position.set(
                0 === currentAxisConfig ? 100 : -100,
                100,
                100
              )
            : 2 === currentAxisConfig || 3 === currentAxisConfig
            ? camera.position.set(
                2 === currentAxisConfig ? 100 : -100,
                100,
                -100
              )
            : camera.position.set(
                100,
                4 === currentAxisConfig ? 100 : -100,
                100
              ),
          camera.lookAt(0, 0, 0);
      }
      async function toggleMode() {
        const e = "automatic" === currentMode ? "manual" : "automatic";
        try {
          const t = await fetch("http://localhost:5000/mode", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ mode: e }),
          });
          if (!t.ok) throw new Error(`HTTP error: ${t.status}`);
          const n = await t.json();
          "published" === n.status &&
            ((currentMode = n.mode),
            (toggleModeButton.textContent = `Mode: ${
              currentMode.charAt(0).toUpperCase() + currentMode.slice(1)
            }`),
            (modeDisplayElement.textContent = currentMode),
            console.log(`Mode changed to: ${currentMode}`));
        } catch (t) {
          console.error("Error changing mode:", t),
            alert(`Failed to change mode: ${t.message}`);
        }
      }
      rotateAxesButton.addEventListener("click", rotateAxes),
        resetOrientationButton.addEventListener("click", resetOrientation),
        toggleModeButton.addEventListener("click", toggleMode),
        window.addEventListener("resize", () => {
          (camera.aspect = window.innerWidth / window.innerHeight),
            camera.updateProjectionMatrix(),
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
      let mouseDown = !1,
        mouseX = 0,
        mouseY = 0;
      document.addEventListener("mousedown", (e) => {
        (mouseDown = !0), (mouseX = e.clientX), (mouseY = e.clientY);
      }),
        document.addEventListener("mouseup", () => {
          mouseDown = !1;
        }),
        document.addEventListener("mousemove", (e) => {
          if (mouseDown) {
            const t = e.clientX - mouseX,
              n = e.clientY - mouseY,
              i = Math.sqrt(
                camera.position.x * camera.position.x +
                  camera.position.y * camera.position.y +
                  camera.position.z * camera.position.z
              ),
              o = Math.atan2(camera.position.y, camera.position.x) + 0.01 * t,
              s = Math.acos(camera.position.z / i) + 0.01 * n,
              a = Math.max(0.1, Math.min(Math.PI - 0.1, s));
            (camera.position.x = i * Math.sin(a) * Math.cos(o)),
              (camera.position.y = i * Math.sin(a) * Math.sin(o)),
              (camera.position.z = i * Math.cos(a)),
              camera.lookAt(0, 0, 0),
              (mouseX = e.clientX),
              (mouseY = e.clientY);
          }
        });
      const serverBaseUrl = "http://localhost:5000",
        currentUrl = `${serverBaseUrl}/current`,
        targetUrl = `${serverBaseUrl}/target`,
        modeUrl = `${serverBaseUrl}/mode`,
        statusElement = document.getElementById("status"),
        positionElement = document.getElementById("position"),
        targetElement = document.getElementById("target");
      let lastPosition = { x: 0, y: 0, z: 0 },
        hasMovedSignificantly = !1;
      function transformCoordinates(e, t, n) {
        return axisConfigs[currentAxisConfig].transform(e, t, n);
      }
      async function fetchCurrentPosition() {
        try {
          const e = await fetch("http://localhost:5000/current_position");
          if (!e.ok) throw new Error(`HTTP error: ${e.status}`);
          const t = await e.json();
          lastPosition = { x: position.x, y: position.y, z: position.z };
          const n = t.x,
            i = t.y,
            o = t.z,
            s = transformCoordinates(n, i, o);
          (position.x = s.x),
            (position.y = s.y),
            (position.z = s.z),
            (positionElement.textContent = `x=${n} y=${i} z=${o}`),
            (statusElement.textContent = "Connected"),
            (statusElement.style.color = "#00ff00");
          const a = Math.sqrt(
            Math.pow(position.x - lastPosition.x, 2) +
              Math.pow(position.y - lastPosition.y, 2) +
              Math.pow(position.z - lastPosition.z, 2)
          );
          (hasMovedSignificantly = a > 0.1),
            hasMovedSignificantly &&
              (trailPoints.push(
                new THREE.Vector3(position.x, position.y, position.z)
              ),
              trailPoints.length > 200 && trailPoints.shift(),
              trailGeometry.setFromPoints(trailPoints)),
            updateTargetLine();
        } catch (e) {
          console.error("Error fetching current position:", e),
            (statusElement.textContent = "Connection Error"),
            (statusElement.style.color = "#ff0000");
        }
      }
      async function fetchTargetPosition() {
        try {
          const e = await fetch("http://localhost:5000/target_position");
          if (!e.ok) throw new Error(`HTTP error: ${e.status}`);
          const t = await e.json(),
            n = t.x,
            i = t.y,
            o = t.z,
            s = transformCoordinates(n, i, o);
          (target.x = s.x),
            (target.y = s.y),
            (target.z = s.z),
            (targetElement.textContent = `x=${n} y=${i} z=${o}`),
            updateTargetLine();
        } catch (e) {
          console.error("Error fetching target position:", e);
        }
      }
      function updateTargetLine() {
        const e = [
          new THREE.Vector3(position.x, position.y, position.z),
          new THREE.Vector3(target.x, target.y, target.z),
        ];
        lineGeometry.setFromPoints(e);
      }
      async function fetchCurrentMode() {
        try {
          const e = await fetch("http://localhost:5000/mode");
          if (!e.ok) throw new Error(`HTTP error: ${e.status}`);
          const t = await e.json();
          (currentMode = t.mode),
            (toggleModeButton.textContent = `Mode: ${
              currentMode.charAt(0).toUpperCase() + currentMode.slice(1)
            }`),
            (modeDisplayElement.textContent = currentMode);
        } catch (e) {
          console.error("Error fetching current mode:", e);
        }
      }
      function animate() {
        requestAnimationFrame(animate),
          (dot.position.x += 0.1 * (position.x - dot.position.x)),
          (dot.position.y += 0.1 * (position.y - dot.position.y)),
          (dot.position.z += 0.1 * (position.z - dot.position.z)),
          (targetDot.position.x = target.x),
          (targetDot.position.y = target.y),
          (targetDot.position.z = target.z),
          renderer.render(scene, camera);
      }
      animate(),
        setInterval(fetchCurrentPosition, 1e3),
        setInterval(fetchTargetPosition, 1e3),
        setInterval(fetchCurrentMode, 2e3),
        resetOrientation(),
        fetchCurrentMode();
    </script>
  </body>
</html>